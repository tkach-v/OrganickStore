{"ast":null,"code":"// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n  var version = \"0.5.4\",\n    has = \"hasOwnProperty\",\n    separator = /[\\.\\/]/,\n    comaseparator = /\\s*,\\s*/,\n    wildcard = \"*\",\n    numsort = function (a, b) {\n      return a - b;\n    },\n    current_event,\n    stop,\n    events = {\n      n: {}\n    },\n    firstDefined = function () {\n      for (var i = 0, ii = this.length; i < ii; i++) {\n        if (typeof this[i] != \"undefined\") {\n          return this[i];\n        }\n      }\n    },\n    lastDefined = function () {\n      var i = this.length;\n      while (--i) {\n        if (typeof this[i] != \"undefined\") {\n          return this[i];\n        }\n      }\n    },\n    objtos = Object.prototype.toString,\n    Str = String,\n    isArray = Array.isArray || function (ar) {\n      return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n    },\n    /*\\\n     * eve\n     [ method ]\n      * Fires event with given `name`, given scope and other parameters.\n      - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n      = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n    eve = function (name, scope) {\n      var oldstop = stop,\n        args = Array.prototype.slice.call(arguments, 2),\n        listeners = eve.listeners(name),\n        z = 0,\n        l,\n        indexed = [],\n        queue = {},\n        out = [],\n        ce = current_event;\n      out.firstDefined = firstDefined;\n      out.lastDefined = lastDefined;\n      current_event = name;\n      stop = 0;\n      for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n        indexed.push(listeners[i].zIndex);\n        if (listeners[i].zIndex < 0) {\n          queue[listeners[i].zIndex] = listeners[i];\n        }\n      }\n      indexed.sort(numsort);\n      while (indexed[z] < 0) {\n        l = queue[indexed[z++]];\n        out.push(l.apply(scope, args));\n        if (stop) {\n          stop = oldstop;\n          return out;\n        }\n      }\n      for (i = 0; i < ii; i++) {\n        l = listeners[i];\n        if (\"zIndex\" in l) {\n          if (l.zIndex == indexed[z]) {\n            out.push(l.apply(scope, args));\n            if (stop) {\n              break;\n            }\n            do {\n              z++;\n              l = queue[indexed[z]];\n              l && out.push(l.apply(scope, args));\n              if (stop) {\n                break;\n              }\n            } while (l);\n          } else {\n            queue[l.zIndex] = l;\n          }\n        } else {\n          out.push(l.apply(scope, args));\n          if (stop) {\n            break;\n          }\n        }\n      }\n      stop = oldstop;\n      current_event = ce;\n      return out;\n    };\n  // Undocumented. Debug only.\n  eve._events = events;\n  /*\\\n   * eve.listeners\n   [ method ]\n    * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n    - name (string) name of the event, dot (`.`) or slash (`/`) separated\n    = (array) array of event handlers\n  \\*/\n  eve.listeners = function (name) {\n    var names = isArray(name) ? name : name.split(separator),\n      e = events,\n      item,\n      items,\n      k,\n      i,\n      ii,\n      j,\n      jj,\n      nes,\n      es = [e],\n      out = [];\n    for (i = 0, ii = names.length; i < ii; i++) {\n      nes = [];\n      for (j = 0, jj = es.length; j < jj; j++) {\n        e = es[j].n;\n        items = [e[names[i]], e[wildcard]];\n        k = 2;\n        while (k--) {\n          item = items[k];\n          if (item) {\n            nes.push(item);\n            out = out.concat(item.f || []);\n          }\n        }\n      }\n      es = nes;\n    }\n    return out;\n  };\n  /*\\\n   * eve.separator\n   [ method ]\n    * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n   * here. Be aware that if you pass a string longer than one character it will be treated as\n   * a list of characters.\n    - separator (string) new separator. Empty string resets to default: `.` or `/`.\n  \\*/\n  eve.separator = function (sep) {\n    if (sep) {\n      sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n      sep = \"[\" + sep + \"]\";\n      separator = new RegExp(sep);\n    } else {\n      separator = /[\\.\\/]/;\n    }\n  };\n  /*\\\n   * eve.on\n   [ method ]\n   **\n   * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n   | eve.on(\"*.under.*\", f);\n   | eve(\"mouse.under.floor\"); // triggers f\n   * Use @eve to trigger the listener.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n   **\n   - name (array) if you don’t want to use separators, you can use array of strings\n   - f (function) event handler function\n   **\n   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n   > Example:\n   | eve.on(\"mouse\", eatIt)(2);\n   | eve.on(\"mouse\", scream);\n   | eve.on(\"mouse\", catchIt)(1);\n   * This will ensure that `catchIt` function will be called before `eatIt`.\n   *\n   * If you want to put your handler before non-indexed handlers, specify a negative value.\n   * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n  \\*/\n  eve.on = function (name, f) {\n    if (typeof f != \"function\") {\n      return function () {};\n    }\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n    for (var i = 0, ii = names.length; i < ii; i++) {\n      (function (name) {\n        var names = isArray(name) ? name : Str(name).split(separator),\n          e = events,\n          exist;\n        for (var i = 0, ii = names.length; i < ii; i++) {\n          e = e.n;\n          e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {\n            n: {}\n          });\n        }\n        e.f = e.f || [];\n        for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n          exist = true;\n          break;\n        }\n        !exist && e.f.push(f);\n      })(names[i]);\n    }\n    return function (zIndex) {\n      if (+zIndex == +zIndex) {\n        f.zIndex = +zIndex;\n      }\n    };\n  };\n  /*\\\n   * eve.f\n   [ method ]\n   **\n   * Returns function that will fire given event with optional arguments.\n   * Arguments that will be passed to the result function will be also\n   * concated to the list of final arguments.\n   | el.onclick = eve.f(\"click\", 1, 2);\n   | eve.on(\"click\", function (a, b, c) {\n   |     console.log(a, b, c); // 1, 2, [event object]\n   | });\n   - event (string) event name\n   - varargs (…) and any other arguments\n   = (function) possible event handler function\n  \\*/\n  eve.f = function (event) {\n    var attrs = [].slice.call(arguments, 1);\n    return function () {\n      eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n    };\n  };\n  /*\\\n   * eve.stop\n   [ method ]\n   **\n   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n  \\*/\n  eve.stop = function () {\n    stop = 1;\n  };\n  /*\\\n   * eve.nt\n   [ method ]\n   **\n   * Could be used inside event handler to figure out actual name of the event.\n   **\n   - subname (string) #optional subname of the event\n   **\n   = (string) name of the event, if `subname` is not specified\n   * or\n   = (boolean) `true`, if current event’s name contains `subname`\n  \\*/\n  eve.nt = function (subname) {\n    var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n    if (subname) {\n      return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n    }\n    return cur;\n  };\n  /*\\\n   * eve.nts\n   [ method ]\n   **\n   * Could be used inside event handler to figure out actual name of the event.\n   **\n   **\n   = (array) names of the event\n  \\*/\n  eve.nts = function () {\n    return isArray(current_event) ? current_event : current_event.split(separator);\n  };\n  /*\\\n   * eve.off\n   [ method ]\n   **\n   * Removes given function from the list of event listeners assigned to given name.\n   * If no arguments specified all the events will be cleared.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n  \\*/\n  /*\\\n   * eve.unbind\n   [ method ]\n   **\n   * See @eve.off\n  \\*/\n  eve.off = eve.unbind = function (name, f) {\n    if (!name) {\n      eve._events = events = {\n        n: {}\n      };\n      return;\n    }\n    var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n    if (names.length > 1) {\n      for (var i = 0, ii = names.length; i < ii; i++) {\n        eve.off(names[i], f);\n      }\n      return;\n    }\n    names = isArray(name) ? name : Str(name).split(separator);\n    var e,\n      key,\n      splice,\n      i,\n      ii,\n      j,\n      jj,\n      cur = [events],\n      inodes = [];\n    for (i = 0, ii = names.length; i < ii; i++) {\n      for (j = 0; j < cur.length; j += splice.length - 2) {\n        splice = [j, 1];\n        e = cur[j].n;\n        if (names[i] != wildcard) {\n          if (e[names[i]]) {\n            splice.push(e[names[i]]);\n            inodes.unshift({\n              n: e,\n              name: names[i]\n            });\n          }\n        } else {\n          for (key in e) if (e[has](key)) {\n            splice.push(e[key]);\n            inodes.unshift({\n              n: e,\n              name: key\n            });\n          }\n        }\n        cur.splice.apply(cur, splice);\n      }\n    }\n    for (i = 0, ii = cur.length; i < ii; i++) {\n      e = cur[i];\n      while (e.n) {\n        if (f) {\n          if (e.f) {\n            for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n              e.f.splice(j, 1);\n              break;\n            }\n            !e.f.length && delete e.f;\n          }\n          for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n            var funcs = e.n[key].f;\n            for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n              funcs.splice(j, 1);\n              break;\n            }\n            !funcs.length && delete e.n[key].f;\n          }\n        } else {\n          delete e.f;\n          for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n            delete e.n[key].f;\n          }\n        }\n        e = e.n;\n      }\n    }\n    // prune inner nodes in path\n    prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n      e = inodes[i];\n      for (key in e.n[e.name].f) {\n        // not empty (has listeners)\n        continue prune;\n      }\n      for (key in e.n[e.name].n) {\n        // not empty (has children)\n        continue prune;\n      }\n      // is empty\n      delete e.n[e.name];\n    }\n  };\n  /*\\\n   * eve.once\n   [ method ]\n   **\n   * Binds given event handler with a given name to only run once then unbind itself.\n   | eve.once(\"login\", f);\n   | eve(\"login\"); // triggers f\n   | eve(\"login\"); // no listeners\n   * Use @eve to trigger the listener.\n   **\n   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n   - f (function) event handler function\n   **\n   = (function) same return function as @eve.on\n  \\*/\n  eve.once = function (name, f) {\n    var f2 = function () {\n      eve.off(name, f2);\n      return f.apply(this, arguments);\n    };\n    return eve.on(name, f2);\n  };\n  /*\\\n   * eve.version\n   [ property (string) ]\n   **\n   * Current version of the library.\n  \\*/\n  eve.version = version;\n  eve.toString = function () {\n    return \"You are running Eve \" + version;\n  };\n  glob.eve = eve;\n  typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () {\n    return eve;\n  }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);","map":{"version":3,"names":["glob","version","has","separator","comaseparator","wildcard","numsort","a","b","current_event","stop","events","n","firstDefined","i","ii","length","lastDefined","objtos","Object","prototype","toString","Str","String","isArray","Array","ar","call","eve","name","scope","oldstop","args","slice","arguments","listeners","z","l","indexed","queue","out","ce","push","zIndex","sort","apply","_events","names","split","e","item","items","k","j","jj","nes","es","concat","f","sep","replace","RegExp","on","exist","hasOwnProperty","event","attrs","nt","subname","cur","join","test","nts","off","unbind","key","splice","inodes","unshift","funcs","prune","once","f2","module","exports","define","amd","window"],"sources":["C:/SigmaSoftware/final-project/node_modules/eve/eve.js"],"sourcesContent":["// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// ┌────────────────────────────────────────────────────────────┐ \\\\\n// │ Eve 0.5.4 - JavaScript Events Library                      │ \\\\\n// ├────────────────────────────────────────────────────────────┤ \\\\\n// │ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) │ \\\\\n// └────────────────────────────────────────────────────────────┘ \\\\\n\n(function (glob) {\n    var version = \"0.5.4\",\n        has = \"hasOwnProperty\",\n        separator = /[\\.\\/]/,\n        comaseparator = /\\s*,\\s*/,\n        wildcard = \"*\",\n        numsort = function (a, b) {\n            return a - b;\n        },\n        current_event,\n        stop,\n        events = {n: {}},\n        firstDefined = function () {\n            for (var i = 0, ii = this.length; i < ii; i++) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        lastDefined = function () {\n            var i = this.length;\n            while (--i) {\n                if (typeof this[i] != \"undefined\") {\n                    return this[i];\n                }\n            }\n        },\n        objtos = Object.prototype.toString,\n        Str = String,\n        isArray = Array.isArray || function (ar) {\n            return ar instanceof Array || objtos.call(ar) == \"[object Array]\";\n        },\n    /*\\\n     * eve\n     [ method ]\n\n     * Fires event with given `name`, given scope and other parameters.\n\n     - name (string) name of the *event*, dot (`.`) or slash (`/`) separated\n     - scope (object) context for the event handlers\n     - varargs (...) the rest of arguments will be sent to event handlers\n\n     = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.\n    \\*/\n        eve = function (name, scope) {\n            var oldstop = stop,\n                args = Array.prototype.slice.call(arguments, 2),\n                listeners = eve.listeners(name),\n                z = 0,\n                l,\n                indexed = [],\n                queue = {},\n                out = [],\n                ce = current_event;\n            out.firstDefined = firstDefined;\n            out.lastDefined = lastDefined;\n            current_event = name;\n            stop = 0;\n            for (var i = 0, ii = listeners.length; i < ii; i++) if (\"zIndex\" in listeners[i]) {\n                indexed.push(listeners[i].zIndex);\n                if (listeners[i].zIndex < 0) {\n                    queue[listeners[i].zIndex] = listeners[i];\n                }\n            }\n            indexed.sort(numsort);\n            while (indexed[z] < 0) {\n                l = queue[indexed[z++]];\n                out.push(l.apply(scope, args));\n                if (stop) {\n                    stop = oldstop;\n                    return out;\n                }\n            }\n            for (i = 0; i < ii; i++) {\n                l = listeners[i];\n                if (\"zIndex\" in l) {\n                    if (l.zIndex == indexed[z]) {\n                        out.push(l.apply(scope, args));\n                        if (stop) {\n                            break;\n                        }\n                        do {\n                            z++;\n                            l = queue[indexed[z]];\n                            l && out.push(l.apply(scope, args));\n                            if (stop) {\n                                break;\n                            }\n                        } while (l)\n                    } else {\n                        queue[l.zIndex] = l;\n                    }\n                } else {\n                    out.push(l.apply(scope, args));\n                    if (stop) {\n                        break;\n                    }\n                }\n            }\n            stop = oldstop;\n            current_event = ce;\n            return out;\n        };\n    // Undocumented. Debug only.\n    eve._events = events;\n    /*\\\n     * eve.listeners\n     [ method ]\n\n     * Internal method which gives you array of all event handlers that will be triggered by the given `name`.\n\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated\n\n     = (array) array of event handlers\n    \\*/\n    eve.listeners = function (name) {\n        var names = isArray(name) ? name : name.split(separator),\n            e = events,\n            item,\n            items,\n            k,\n            i,\n            ii,\n            j,\n            jj,\n            nes,\n            es = [e],\n            out = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            nes = [];\n            for (j = 0, jj = es.length; j < jj; j++) {\n                e = es[j].n;\n                items = [e[names[i]], e[wildcard]];\n                k = 2;\n                while (k--) {\n                    item = items[k];\n                    if (item) {\n                        nes.push(item);\n                        out = out.concat(item.f || []);\n                    }\n                }\n            }\n            es = nes;\n        }\n        return out;\n    };\n    /*\\\n     * eve.separator\n     [ method ]\n\n     * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours\n     * here. Be aware that if you pass a string longer than one character it will be treated as\n     * a list of characters.\n\n     - separator (string) new separator. Empty string resets to default: `.` or `/`.\n    \\*/\n    eve.separator = function (sep) {\n        if (sep) {\n            sep = Str(sep).replace(/(?=[\\.\\^\\]\\[\\-])/g, \"\\\\\");\n            sep = \"[\" + sep + \"]\";\n            separator = new RegExp(sep);\n        } else {\n            separator = /[\\.\\/]/;\n        }\n    };\n    /*\\\n     * eve.on\n     [ method ]\n     **\n     * Binds given event handler with a given name. You can use wildcards “`*`” for the names:\n     | eve.on(\"*.under.*\", f);\n     | eve(\"mouse.under.floor\"); // triggers f\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     - name (array) if you don’t want to use separators, you can use array of strings\n     - f (function) event handler function\n     **\n     = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.\n     > Example:\n     | eve.on(\"mouse\", eatIt)(2);\n     | eve.on(\"mouse\", scream);\n     | eve.on(\"mouse\", catchIt)(1);\n     * This will ensure that `catchIt` function will be called before `eatIt`.\n     *\n     * If you want to put your handler before non-indexed handlers, specify a negative value.\n     * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.\n    \\*/\n    eve.on = function (name, f) {\n        if (typeof f != \"function\") {\n            return function () {};\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n        for (var i = 0, ii = names.length; i < ii; i++) {\n            (function (name) {\n                var names = isArray(name) ? name : Str(name).split(separator),\n                    e = events,\n                    exist;\n                for (var i = 0, ii = names.length; i < ii; i++) {\n                    e = e.n;\n                    e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});\n                }\n                e.f = e.f || [];\n                for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {\n                    exist = true;\n                    break;\n                }\n                !exist && e.f.push(f);\n            }(names[i]));\n        }\n        return function (zIndex) {\n            if (+zIndex == +zIndex) {\n                f.zIndex = +zIndex;\n            }\n        };\n    };\n    /*\\\n     * eve.f\n     [ method ]\n     **\n     * Returns function that will fire given event with optional arguments.\n     * Arguments that will be passed to the result function will be also\n     * concated to the list of final arguments.\n     | el.onclick = eve.f(\"click\", 1, 2);\n     | eve.on(\"click\", function (a, b, c) {\n     |     console.log(a, b, c); // 1, 2, [event object]\n     | });\n     - event (string) event name\n     - varargs (…) and any other arguments\n     = (function) possible event handler function\n    \\*/\n    eve.f = function (event) {\n        var attrs = [].slice.call(arguments, 1);\n        return function () {\n            eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));\n        };\n    };\n    /*\\\n     * eve.stop\n     [ method ]\n     **\n     * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.\n    \\*/\n    eve.stop = function () {\n        stop = 1;\n    };\n    /*\\\n     * eve.nt\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     - subname (string) #optional subname of the event\n     **\n     = (string) name of the event, if `subname` is not specified\n     * or\n     = (boolean) `true`, if current event’s name contains `subname`\n    \\*/\n    eve.nt = function (subname) {\n        var cur = isArray(current_event) ? current_event.join(\".\") : current_event;\n        if (subname) {\n            return new RegExp(\"(?:\\\\.|\\\\/|^)\" + subname + \"(?:\\\\.|\\\\/|$)\").test(cur);\n        }\n        return cur;\n    };\n    /*\\\n     * eve.nts\n     [ method ]\n     **\n     * Could be used inside event handler to figure out actual name of the event.\n     **\n     **\n     = (array) names of the event\n    \\*/\n    eve.nts = function () {\n        return isArray(current_event) ? current_event : current_event.split(separator);\n    };\n    /*\\\n     * eve.off\n     [ method ]\n     **\n     * Removes given function from the list of event listeners assigned to given name.\n     * If no arguments specified all the events will be cleared.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n    \\*/\n    /*\\\n     * eve.unbind\n     [ method ]\n     **\n     * See @eve.off\n    \\*/\n    eve.off = eve.unbind = function (name, f) {\n        if (!name) {\n            eve._events = events = {n: {}};\n            return;\n        }\n        var names = isArray(name) ? isArray(name[0]) ? name : [name] : Str(name).split(comaseparator);\n        if (names.length > 1) {\n            for (var i = 0, ii = names.length; i < ii; i++) {\n                eve.off(names[i], f);\n            }\n            return;\n        }\n        names = isArray(name) ? name : Str(name).split(separator);\n        var e,\n            key,\n            splice,\n            i, ii, j, jj,\n            cur = [events],\n            inodes = [];\n        for (i = 0, ii = names.length; i < ii; i++) {\n            for (j = 0; j < cur.length; j += splice.length - 2) {\n                splice = [j, 1];\n                e = cur[j].n;\n                if (names[i] != wildcard) {\n                    if (e[names[i]]) {\n                        splice.push(e[names[i]]);\n                        inodes.unshift({\n                            n: e,\n                            name: names[i]\n                        });\n                    }\n                } else {\n                    for (key in e) if (e[has](key)) {\n                        splice.push(e[key]);\n                        inodes.unshift({\n                            n: e,\n                            name: key\n                        });\n                    }\n                }\n                cur.splice.apply(cur, splice);\n            }\n        }\n        for (i = 0, ii = cur.length; i < ii; i++) {\n            e = cur[i];\n            while (e.n) {\n                if (f) {\n                    if (e.f) {\n                        for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {\n                            e.f.splice(j, 1);\n                            break;\n                        }\n                        !e.f.length && delete e.f;\n                    }\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        var funcs = e.n[key].f;\n                        for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {\n                            funcs.splice(j, 1);\n                            break;\n                        }\n                        !funcs.length && delete e.n[key].f;\n                    }\n                } else {\n                    delete e.f;\n                    for (key in e.n) if (e.n[has](key) && e.n[key].f) {\n                        delete e.n[key].f;\n                    }\n                }\n                e = e.n;\n            }\n        }\n        // prune inner nodes in path\n        prune: for (i = 0, ii = inodes.length; i < ii; i++) {\n            e = inodes[i];\n            for (key in e.n[e.name].f) {\n                // not empty (has listeners)\n                continue prune;\n            }\n            for (key in e.n[e.name].n) {\n                // not empty (has children)\n                continue prune;\n            }\n            // is empty\n            delete e.n[e.name];\n        }\n    };\n    /*\\\n     * eve.once\n     [ method ]\n     **\n     * Binds given event handler with a given name to only run once then unbind itself.\n     | eve.once(\"login\", f);\n     | eve(\"login\"); // triggers f\n     | eve(\"login\"); // no listeners\n     * Use @eve to trigger the listener.\n     **\n     - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards\n     - f (function) event handler function\n     **\n     = (function) same return function as @eve.on\n    \\*/\n    eve.once = function (name, f) {\n        var f2 = function () {\n            eve.off(name, f2);\n            return f.apply(this, arguments);\n        };\n        return eve.on(name, f2);\n    };\n    /*\\\n     * eve.version\n     [ property (string) ]\n     **\n     * Current version of the library.\n    \\*/\n    eve.version = version;\n    eve.toString = function () {\n        return \"You are running Eve \" + version;\n    };\n    glob.eve = eve;\n    typeof module != \"undefined\" && module.exports ? module.exports = eve : typeof define === \"function\" && define.amd ? define(\"eve\", [], function () { return eve; }) : glob.eve = eve;\n})(typeof window != \"undefined\" ? window : this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}